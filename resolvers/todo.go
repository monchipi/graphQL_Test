package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.41

import (
	"context"
	"fmt"
	"strconv"

	"github.com/monchipi/ex-myserver/models"
    _ "github.com/monchipi/ex-myserver/graph/generated"
)

//type todoResolver struct{ *Resolver }

// Assert that todoResolver conforms to the generated.TodoResolver interface
//var _ generated.TodoResolver = (*todoResolver)(nil)

// CreateTodo is the resolver for the createTodo field.
func (r *mutationResolver) CreateTodo(ctx context.Context, input models.NewTodo) (*models.Todo, error) {
	res, err := r.DB.Exec("INSERT INTO todos (text, isCompleted) VALUES (?, false)", input.Text)
	if err != nil {
		return nil, fmt.Errorf("DB Exec error: %v", err)
	}
	id, err := res.LastInsertId()
	if err != nil {
		return nil, fmt.Errorf("LastInsertID Error: %v", err)
	}

	idStr := strconv.FormatInt(id, 10)
	return &models.Todo{
		ID:   idStr,
		Text: input.Text,
		IsCompleted: false,
	}, nil
}

func (r *mutationResolver) DoneTodo(ctx context.Context, id int) (*models.Todo, error) {
    // Update the isCompleted field in the database
    _, err := r.DB.Exec("UPDATE todos SET isCompleted = true WHERE id = ?", id)

    if err != nil {
        return nil, fmt.Errorf("DB Exec error: %v", err)
    }

    // Optionally, retrieve the updated todo item from the database
    // This step is necessary if you want to return the complete Todo object with updated fields
    var todo models.Todo
    err = r.DB.QueryRow("SELECT id, text, isCompleted FROM todos WHERE id = ?", id).Scan(&todo.ID, &todo.Text, &todo.IsCompleted)
    if err != nil {
        return nil, fmt.Errorf("DB QueryRow error: %v", err)
    }

    return &todo, nil
}


// Todos is the resolver for the todos field.
func (r *queryResolver) Todos(ctx context.Context) ([]*models.Todo, error) {
	rows, err := r.DB.Query("SELECT id, text, IsCompleted From todos")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var todos []*models.Todo
	for rows.Next() {
		var t models.Todo
		if err := rows.Scan(&t.ID, &t.Text, &t.IsCompleted); err != nil {
			return nil, err
		}
		todos = append(todos, &t)
	}
	return todos, nil
}
