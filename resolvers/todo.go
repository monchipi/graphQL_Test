package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.41

import (
	"context"
	"fmt"
	"strconv"

	"github.com/monchipi/ex-myserver/models"
    _ "github.com/monchipi/ex-myserver/graph/generated"
)

//type todoResolver struct{ *Resolver }

// Assert that todoResolver conforms to the generated.TodoResolver interface
//var _ generated.TodoResolver = (*todoResolver)(nil)

// CreateTodo is the resolver for the createTodo field.
func (r *mutationResolver) CreateTodo(ctx context.Context, input models.NewTodo) (*models.Todo, error) {
	res, err := r.DB.Exec("INSERT INTO todos (text, isCompleted) VALUES (?, 0)", input.Text)
	if err != nil {
		return nil, fmt.Errorf("DB Exec error: %v", err)
	}
	id, err := res.LastInsertId()
	if err != nil {
		return nil, fmt.Errorf("LastInsertID Error: %v", err)
	}

	idStr := strconv.FormatInt(id, 10)
	return &models.Todo{
		ID:   idStr,
		Text: input.Text,
		IsCompleted: false,
	}, nil
}

func (r *mutationResolver) DeleteTodo(ctx context.Context, id int) (bool, error) {
    _, err := r.DB.Exec("DELETE FROM todos WHERE id = ?", id)

    if err != nil {
        return false, fmt.Errorf("DB Exec error: %v", err)
    }

    return true, nil
}



// Todos is the resolver for the todos field.
func (r *queryResolver) Todos(ctx context.Context) ([]*models.Todo, error) {
	rows, err := r.DB.Query("SELECT id, text, IsCompIsCompletedd From todos")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var todos []*models.Todo
	for rows.Next() {
		var t models.Todo
		if err := rows.Scan(&t.ID, &t.Text, &t.IsCompleted); err != nil {
			return nil, err
		}
		todos = append(todos, &t)
	}
	return todos, nil
}
